// Doc: https://www.prisma.io/docs/orm/overview/databases/mongodb

// To update client (code type definition) to reflect changes to this file:
// npx prisma generate

// To update the schema of the actual database to reflect changes to this file:
// (You may be warned of data loss in the process)
// npx prisma db push

// Project conventions:
//   - All models in titlecase
//   - All fields in lowercase
//   - All relations explicitly named (@relation(name: ""))
//   - All fields that is an array type has plural field names
//   - Written order: attributes, foreign keys, relations
//   - "updatedAt" fields are updated automatically, while "lastUpdated" fields should be manually updated

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

//////////////////////
// Group A: User-related
//////////////////////

// Some fields in this model are used by lucia-auth
model User {
  id                     String         @id @default(auto()) @map("_id") @db.ObjectId
  username               String         @unique
  email                  String         @unique
  password               String
  createdAt              DateTime       @default(now()) @db.Date
  accountInfoLastUpdated DateTime
  role                   Role           @default(USER)
  digitalBalance         Float          @default(0)
  userConfig             UserConfig
  userCryptoInfo         UserCryptoInfo
  suspended              Boolean        @default(false)
  onBoardingCompleted    Boolean        @default(false)

  followers              UserFollow[]         @relation(name: "UserFollowTarget")
  followedUsers          UserFollow[]         @relation(name: "UserFollow")
  sessions               Session[]            @relation(name: "UserSession")
  posts                  Post[]               @relation(name: "UserPost")
  digitalTransactions    DigitalTransaction[] @relation(name: "UserDigitalTransaction")
  sentDirectMessages     DirectMessage[]      @relation(name: "DirectMessageSender")
  receivedDirectMessages DirectMessage[]      @relation(name: "DirectMessageReceiver")
  moderationRecords      ModerationRecord[]   @relation(name: "UserModerationRecord")
  moderationHits         ModerationRecord[]   @relation(name: "UserModerationHit")
  pollVotes              PollVote[]           @relation(name: "UserPollVote")
  postLikes              PostLike[]           @relation(name: "UserPostLike")
  postSaves              PostSave[]           @relation(name: "UserPostSave")
  notifications          Notification[]       @relation(name: "UserNotification")
}

enum Role {
  USER
  VERIFIED_USER
  ADMIN
}

type UserConfig {
  displayName String   @default("")
  avatarUrl   String?
  bannerUrl   String?
  bio         String   @default("")
  lastUpdated DateTime @default(now()) @db.Date
}

type UserCryptoInfo {
  walletAddress   String?
  cryptoBookmarks String[] // remark: list of cryptoIds
  cryptoHoldings  CryptoHolding[]
  lastUpdated     DateTime        @default(now()) @db.Date
}

type CryptoHolding {
  cryptoId String
  amount   Float
}

// This model is used by lucia-auth
model Session {
  trueId    String   @id @default(auto()) @map("_id") @db.ObjectId
  id        String   @unique
  expiresAt DateTime @db.Date

  userId String @db.ObjectId

  user User @relation(name: "UserSession", references: [id], fields: [userId], onDelete: Cascade)
}

model UserFollow {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())

  initiatorId String @db.ObjectId
  targetId    String @db.ObjectId

  initiator User @relation("UserFollow", references: [id], fields: [initiatorId], onDelete: Cascade)
  target    User @relation("UserFollowTarget", references: [id], fields: [targetId], onDelete: Cascade)

  @@unique([initiatorId, targetId])
}

model DigitalTransaction {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  item      String
  amount    Float
  createdAt DateTime @default(now())

  initiatorId String @db.ObjectId

  initiator User @relation(name: "UserDigitalTransaction", references: [id], fields: [initiatorId], onDelete: Cascade)
}

model DirectMessage {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  content   String
  createdAt DateTime @default(now())

  senderId   String @db.ObjectId
  receiverId String @db.ObjectId

  sender   User @relation(name: "DirectMessageSender", references: [id], fields: [senderId], onDelete: Cascade)
  receiver User @relation(name: "DirectMessageReceiver", references: [id], fields: [receiverId], onDelete: NoAction)
}

model Notification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  content   String
  link      String?
  unread    Boolean  @default(true)
  createdAt DateTime @default(now())
  expiry    DateTime

  receiverId String @db.ObjectId

  receiver User @relation(name: "UserNotification", references: [id], fields: [receiverId], onDelete: Cascade)
}

//////////////////////
// Group B: Post-related
//////////////////////

model Post {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  content         String
  createdAt       DateTime         @default(now())
  pollOptions     PollOption[]
  userMedia       UserMedia[]
  textualContexts TextualContext[]
  suspended       Boolean          @default(false)
  repostChainIds  String[]         @db.ObjectId

  authorId          String  @db.ObjectId
  repostingPostId   String? @db.ObjectId
  parentPostId      String? @db.ObjectId
  parentCommunityId String? @db.ObjectId

  postHashtags     PostHashtag[]      @relation(name: "PostHashtag")
  postCryptoTopics PostCryptoTopic[]  @relation(name: "PostCryptoTopic")
  author           User               @relation(name: "UserPost", fields: [authorId], references: [id], onDelete: NoAction)
  repostingPost    Post?              @relation(name: "Repost", references: [id], fields: [repostingPostId], onDelete: NoAction, onUpdate: NoAction)
  repostedOnPosts  Post[]             @relation(name: "Repost")
  parentPost       Post?              @relation(name: "PostTree", references: [id], fields: [parentPostId], onDelete: NoAction, onUpdate: NoAction)
  childPosts       Post[]             @relation(name: "PostTree")
  parentCommunity  Community?         @relation(name: "CommunityPost", references: [id], fields: [parentCommunityId], onDelete: NoAction)
  moderationHits   ModerationRecord[] @relation(name: "PostModerationHit")
  pollVotes        PollVote[]         @relation(name: "PostPollVote")
  postLikes        PostLike[]         @relation(name: "PostPostLike")
  postSaves        PostSave[]         @relation(name: "PostPostSave")
}

type PollOption {
  description String
}

type UserMedia {
  url     String
  type    UserMediaType
  altText String?
}

type TextualContext {
  href String?
  text String
}

enum UserMediaType {
  IMAGE
  VIDEO
}

model PostLike {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())

  postId String @db.ObjectId
  userId String @db.ObjectId

  post Post @relation(name: "PostPostLike", references: [id], fields: [postId], onDelete: Cascade)
  user User @relation(name: "UserPostLike", references: [id], fields: [userId], onDelete: Cascade)

  @@unique([postId, userId])
}

model PostSave {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())

  postId String @db.ObjectId
  userId String @db.ObjectId

  post Post @relation(name: "PostPostSave", references: [id], fields: [postId], onDelete: Cascade)
  user User @relation(name: "UserPostSave", references: [id], fields: [userId], onDelete: Cascade)

  @@unique([postId, userId])
}

model PollVote {
  id           String @id @default(auto()) @map("_id") @db.ObjectId
  optionNumber Int

  parentPostId String @db.ObjectId
  voterId      String @db.ObjectId

  parentPost Post @relation(name: "PostPollVote", references: [id], fields: [parentPostId], onDelete: Cascade)
  voter      User @relation(name: "UserPollVote", references: [id], fields: [voterId], onDelete: Cascade)

  @@unique([parentPostId, voterId])
}

model PostHashtag {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  tagText   String
  createdAt DateTime @default(now())

  postId String @db.ObjectId

  post Post @relation(name: "PostHashtag", references: [id], fields: [postId], onDelete: Cascade)

  @@unique([tagText, postId])
  @@index([tagText])
}

model PostCryptoTopic {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  cryptoId  String
  createdAt DateTime @default(now())

  postId String @db.ObjectId

  post Post @relation(name: "PostCryptoTopic", references: [id], fields: [postId], onDelete: Cascade)

  @@unique([cryptoId, postId])
  @@index([cryptoId])
}

model Community {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  handle        String   @unique
  displayedName String
  avatarUrl     String?
  bannerUrl     String?
  description   String   @default("")
  isExclusive   Boolean
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  suspended     Boolean  @default(false)

  posts          Post[]             @relation(name: "CommunityPost")
  moderationHits ModerationRecord[] @relation(name: "CommunityModerationHit")
}

//////////////////////
// Group C: Moderation
//////////////////////

model ModerationRecord {
  id         String                 @id @default(auto()) @map("_id") @db.ObjectId
  descriptor String
  comment    String
  targetType ModerationTargetType[]
  details    Json[] // Mock-up: [{ table: { field: { field: { from: "", to: "" | null } } } }]
  createdAt  DateTime               @default(now())

  initiatorId       String  @db.ObjectId
  targetUserId      String? @db.ObjectId
  targetPostId      String? @db.ObjectId
  targetCommunityId String? @db.ObjectId

  initiator       User       @relation(name: "UserModerationRecord", references: [id], fields: [initiatorId], onDelete: NoAction)
  targetUser      User?      @relation(name: "UserModerationHit", references: [id], fields: [targetUserId], onDelete: NoAction)
  targetPost      Post?      @relation(name: "PostModerationHit", references: [id], fields: [targetPostId], onDelete: NoAction)
  targetCommunity Community? @relation(name: "CommunityModerationHit", references: [id], fields: [targetCommunityId], onDelete: NoAction)
}

enum ModerationTargetType {
  USER
  POST
  COMMUNITY
}

//////////////////////
// Group D: Others
//////////////////////

model Crypto {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  cryptoId  String   @unique
  symbol    String
  name      String
  priceUsd  Float
  updatedAt DateTime @updatedAt
}

model SystemMetadata {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  key   String @unique
  value Json
}
